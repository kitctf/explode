#!/bin/env -S uv run
# -*- coding: utf-8 -*-
# Template by explode

from pwn import ELF, args, context, gdb, log, process, remote
import pwnlib.tubes
{{if smt}}import os
from pysmt.logics import QF_BOOL, QF_BV
from pysmt.shortcuts import get_env, Solver, Symbol
from pysmt.typing import BV8

bitwuzla_name = "bitwuzla"
path = ["bitwuzla"]
env = get_env()
env.factory.add_generic_solver(bitwuzla_name, path, [QF_BV, QF_BOOL])

def is_bitwuzla_in_path():
    for path in os.environ["PATH"].split(os.pathsep):
        if os.path.isfile(os.path.join(path, "bitwuzla")):
            return True
    return False
if is_bitwuzla_in_path():
    solver_name = "bitwuzla"
else:
    solver_name = "z3"
solver = Solver(name=solver_name)
{{endif}}

{{if not shell_target}}
TARGET_PATH = {{if target}}{target}{{else}}None{{endif}}
if args.EXE or TARGET_PATH:
    exe = context.binary = ELF(args.EXE or TARGET_PATH)
else:
    exe = None
{{endif}}

{{if terminal}}
context.update(terminal={terminal})
{{endif}}

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
host = args.HOST or {host}
port = int(args.PORT) if args.PORT else {port}

# TODO: SSH support

# TODO: libc upport

{{if appsec}}
server = None
def start_appsec(argv=[], *a, **kw) -> pwnlib.tubes.tube.tube:
    '''Start the exploit against the target.'''
    global gdb_api
    global server

    if not args.REMOTE and not server:
        server = process(["./server", "--port", str(port)])
    remote_tube = remote(host, port)

    if args.GDB and exe:
        if args.REMOTE:
            log.error("Can't debug on remote")
        (_, gdb_api) = gdb.attach("handler", gdbscript=gdbscript, *a, **kw, api = True)
        return remote_tube
    elif exe:
        return remote_tube
    else:
        return None
{{else}}
def start(argv=[], *a, **kw) -> pwnlib.tubes.tube.tube:
    '''Start the exploit against the target.'''
{{if not shell_target}}
    if args.GDB and exe:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(host, port{{if ssl}}, ssl = True{{endif}}{{if udp}}, typ="udp"{{endif}})
    elif exe:
        return process([exe.path] + argv, *a, **kw)
    else:
        return None
{{else}}
if args.REMOTE:
        return remote(host, port{{if ssl}}, ssl = True{{endif}}{{if udp}}, typ="udp"{{endif}})
    else:
        return process([{target}] + argv, *a, **kw, shell=True)
{{endif}}
{{endif}}


{{if not shell_target}}
# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
if exe:
    gdbscript = ("tbreak main\nc" if 'main' in exe.symbols else f"tbreak *0x\{exe.entry:x}") + f'''
    '''
{{endif}}


#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

{{if not smt}}flag = None{{else}}FLAG_LENGTH = 32
flag = [Symbol(f"flag[\{i}]", BV8) for i in range(FLAG_LENGTH)]
{{endif}}

{{if appsec}}
with start_appsec() as io:
    # Exploit goes here
    io.interactive()
{{else}}
io = start()

{{if not shell_target}}
# shellcode = asm(shellcraft.sh())
# payload = fit(\{
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
{{endif}}
{{endif}}

{{if not smt}}
if flag:
    log.success(flag)
else:
    log.warning("No flag yet :(")
    {{if not appsec}}io.interactive(){{endif}}
{{else}}
is_sat = solver.solve()
if is_sat:
    model = solver.get_model()
    flag_res = bytes([(model.get_py_value(flag_char)) for flag_char in flag])
    try:
        log.success(flag_res.decode())
    except:
        print(model)
        print(flag_res)
else:
    solver.error("UNSAT")
    print(solver.unsat_core())
{{endif}}

